{"ast":null,"code":"var slice = Array.prototype.slice;\nexport default function createOrderedCSSStyleSheet(sheet) {\n  var groups = {};\n  var selectors = {};\n  if (sheet != null) {\n    var group;\n    slice.call(sheet.cssRules).forEach(function (cssRule, i) {\n      var cssText = cssRule.cssText;\n      if (cssText.indexOf('stylesheet-group') > -1) {\n        group = decodeGroupRule(cssRule);\n        groups[group] = {\n          start: i,\n          rules: [cssText]\n        };\n      } else {\n        var selectorText = getSelectorText(cssText);\n        if (selectorText != null) {\n          selectors[selectorText] = true;\n          groups[group].rules.push(cssText);\n        }\n      }\n    });\n  }\n  function sheetInsert(sheet, group, text) {\n    var orderedGroups = getOrderedGroups(groups);\n    var groupIndex = orderedGroups.indexOf(group);\n    var nextGroupIndex = groupIndex + 1;\n    var nextGroup = orderedGroups[nextGroupIndex];\n    var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;\n    var isInserted = insertRuleAt(sheet, text, position);\n    if (isInserted) {\n      if (groups[group].start == null) {\n        groups[group].start = position;\n      }\n      for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {\n        var groupNumber = orderedGroups[i];\n        var previousStart = groups[groupNumber].start;\n        groups[groupNumber].start = previousStart + 1;\n      }\n    }\n    return isInserted;\n  }\n  var OrderedCSSStyleSheet = {\n    getTextContent: function getTextContent() {\n      return getOrderedGroups(groups).map(function (group) {\n        var rules = groups[group].rules;\n        return rules.join('\\n');\n      }).join('\\n');\n    },\n    insert: function insert(cssText, groupValue) {\n      var group = Number(groupValue);\n      if (groups[group] == null) {\n        var markerRule = encodeGroupRule(group);\n        groups[group] = {\n          start: null,\n          rules: [markerRule]\n        };\n        if (sheet != null) {\n          sheetInsert(sheet, group, markerRule);\n        }\n      }\n      var selectorText = getSelectorText(cssText);\n      if (selectorText != null && selectors[selectorText] == null) {\n        selectors[selectorText] = true;\n        groups[group].rules.push(cssText);\n        if (sheet != null) {\n          var isInserted = sheetInsert(sheet, group, cssText);\n          if (!isInserted) {\n            groups[group].rules.pop();\n          }\n        }\n      }\n    }\n  };\n  return OrderedCSSStyleSheet;\n}\nfunction encodeGroupRule(group) {\n  return \"[stylesheet-group=\\\"\" + group + \"\\\"]{}\";\n}\nfunction decodeGroupRule(cssRule) {\n  return Number(cssRule.selectorText.split(/[\"']/)[1]);\n}\nfunction getOrderedGroups(obj) {\n  return Object.keys(obj).map(Number).sort(function (a, b) {\n    return a > b ? 1 : -1;\n  });\n}\nvar pattern = /\\s*([,])\\s*/g;\nfunction getSelectorText(cssText) {\n  var selector = cssText.split('{')[0].trim();\n  return selector !== '' ? selector.replace(pattern, '$1') : null;\n}\nfunction insertRuleAt(root, cssText, position) {\n  try {\n    root.insertRule(cssText, position);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","map":{"version":3,"names":["slice","Array","prototype","createOrderedCSSStyleSheet","sheet","groups","selectors","group","call","cssRules","forEach","cssRule","i","cssText","indexOf","decodeGroupRule","start","rules","selectorText","getSelectorText","push","sheetInsert","text","orderedGroups","getOrderedGroups","groupIndex","nextGroupIndex","nextGroup","position","length","isInserted","insertRuleAt","groupNumber","previousStart","OrderedCSSStyleSheet","getTextContent","map","join","insert","groupValue","Number","markerRule","encodeGroupRule","pop","split","obj","Object","keys","sort","a","b","pattern","selector","trim","replace","root","insertRule","e"],"sources":["C:/Users/adamk/Downloads/kasino9/node_modules/react-native-web/src/exports/StyleSheet/createOrderedCSSStyleSheet.js"],"sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n */\n\ntype Groups = { [key: number]: { start: ?number, rules: Array<string> } };\ntype Selectors = { [key: string]: boolean };\n\nconst slice = Array.prototype.slice;\n\n/**\n * Order-based insertion of CSS.\n *\n * Each rule is associated with a numerically defined group.\n * Groups are ordered within the style sheet according to their number, with the\n * lowest first.\n *\n * Groups are implemented using marker rules. The selector of the first rule of\n * each group is used only to encode the group number for hydration. An\n * alternative implementation could rely on CSSMediaRule, allowing groups to be\n * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is\n * broken.\n * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule\n * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674\n */\nexport default function createOrderedCSSStyleSheet(sheet: ?CSSStyleSheet) {\n  const groups: Groups = {};\n  const selectors: Selectors = {};\n\n  /**\n   * Hydrate approximate record from any existing rules in the sheet.\n   */\n  if (sheet != null) {\n    let group;\n    slice.call(sheet.cssRules).forEach((cssRule, i) => {\n      const cssText = cssRule.cssText;\n      // Create record of existing selectors and rules\n      if (cssText.indexOf('stylesheet-group') > -1) {\n        group = decodeGroupRule(cssRule);\n        groups[group] = { start: i, rules: [cssText] };\n      } else {\n        const selectorText = getSelectorText(cssText);\n        if (selectorText != null) {\n          selectors[selectorText] = true;\n          groups[group].rules.push(cssText);\n        }\n      }\n    });\n  }\n\n  function sheetInsert(sheet, group, text) {\n    const orderedGroups = getOrderedGroups(groups);\n    const groupIndex = orderedGroups.indexOf(group);\n    const nextGroupIndex = groupIndex + 1;\n    const nextGroup = orderedGroups[nextGroupIndex];\n    // Insert rule before the next group, or at the end of the stylesheet\n    const position =\n      nextGroup != null && groups[nextGroup].start != null\n        ? groups[nextGroup].start\n        : sheet.cssRules.length;\n    const isInserted = insertRuleAt(sheet, text, position);\n\n    if (isInserted) {\n      // Set the starting index of the new group\n      if (groups[group].start == null) {\n        groups[group].start = position;\n      }\n      // Increment the starting index of all subsequent groups\n      for (let i = nextGroupIndex; i < orderedGroups.length; i += 1) {\n        const groupNumber = orderedGroups[i];\n        const previousStart = groups[groupNumber].start;\n        groups[groupNumber].start = previousStart + 1;\n      }\n    }\n\n    return isInserted;\n  }\n\n  const OrderedCSSStyleSheet = {\n    /**\n     * The textContent of the style sheet.\n     */\n    getTextContent(): string {\n      return getOrderedGroups(groups)\n        .map(group => {\n          const rules = groups[group].rules;\n          return rules.join('\\n');\n        })\n        .join('\\n');\n    },\n\n    /**\n     * Insert a rule into the style sheet\n     */\n    insert(cssText: string, groupValue: number) {\n      const group = Number(groupValue);\n\n      // Create a new group.\n      if (groups[group] == null) {\n        const markerRule = encodeGroupRule(group);\n        // Create the internal record.\n        groups[group] = { start: null, rules: [markerRule] };\n        // Update CSSOM.\n        if (sheet != null) {\n          sheetInsert(sheet, group, markerRule);\n        }\n      }\n\n      // selectorText is more reliable than cssText for insertion checks. The\n      // browser excludes vendor-prefixed properties and rewrites certain values\n      // making cssText more likely to be different from what was inserted.\n      const selectorText = getSelectorText(cssText);\n      if (selectorText != null && selectors[selectorText] == null) {\n        // Update the internal records.\n        selectors[selectorText] = true;\n        groups[group].rules.push(cssText);\n        // Update CSSOM.\n        if (sheet != null) {\n          const isInserted = sheetInsert(sheet, group, cssText);\n          if (!isInserted) {\n            // Revert internal record change if a rule was rejected (e.g.,\n            // unrecognized pseudo-selector)\n            groups[group].rules.pop();\n          }\n        }\n      }\n    }\n  };\n\n  return OrderedCSSStyleSheet;\n}\n\n/**\n * Helper functions\n */\n\nfunction encodeGroupRule(group) {\n  return `[stylesheet-group=\"${group}\"]{}`;\n}\n\nfunction decodeGroupRule(cssRule) {\n  return Number(cssRule.selectorText.split(/[\"']/)[1]);\n}\n\nfunction getOrderedGroups(obj: { [key: number]: any }) {\n  return Object.keys(obj)\n    .map(Number)\n    .sort((a, b) => (a > b ? 1 : -1));\n}\n\nconst pattern = /\\s*([,])\\s*/g;\nfunction getSelectorText(cssText) {\n  const selector = cssText.split('{')[0].trim();\n  return selector !== '' ? selector.replace(pattern, '$1') : null;\n}\n\nfunction insertRuleAt(root, cssText: string, position: number): boolean {\n  try {\n    // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.\n    root.insertRule(cssText, position);\n    return true;\n  } catch (e) {\n    // JSDOM doesn't support `CSSSMediaRule#insertRule`.\n    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.\n    return false;\n  }\n}\n"],"mappings":"AAYA,IAAMA,KAAK,GAAGC,KAAK,CAACC,SAAS,CAACF,KAAK;AAiBnC,eAAe,SAASG,0BAA0BA,CAACC,KAAqB,EAAE;EACxE,IAAMC,MAAc,GAAG,CAAC,CAAC;EACzB,IAAMC,SAAoB,GAAG,CAAC,CAAC;EAK/B,IAAIF,KAAK,IAAI,IAAI,EAAE;IACjB,IAAIG,KAAK;IACTP,KAAK,CAACQ,IAAI,CAACJ,KAAK,CAACK,QAAQ,CAAC,CAACC,OAAO,CAAC,UAACC,OAAO,EAAEC,CAAC,EAAK;MACjD,IAAMC,OAAO,GAAGF,OAAO,CAACE,OAAO;MAE/B,IAAIA,OAAO,CAACC,OAAO,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,EAAE;QAC5CP,KAAK,GAAGQ,eAAe,CAACJ,OAAO,CAAC;QAChCN,MAAM,CAACE,KAAK,CAAC,GAAG;UAAES,KAAK,EAAEJ,CAAC;UAAEK,KAAK,EAAE,CAACJ,OAAO;QAAE,CAAC;MAChD,CAAC,MAAM;QACL,IAAMK,YAAY,GAAGC,eAAe,CAACN,OAAO,CAAC;QAC7C,IAAIK,YAAY,IAAI,IAAI,EAAE;UACxBZ,SAAS,CAACY,YAAY,CAAC,GAAG,IAAI;UAC9Bb,MAAM,CAACE,KAAK,CAAC,CAACU,KAAK,CAACG,IAAI,CAACP,OAAO,CAAC;QACnC;MACF;IACF,CAAC,CAAC;EACJ;EAEA,SAASQ,WAAWA,CAACjB,KAAK,EAAEG,KAAK,EAAEe,IAAI,EAAE;IACvC,IAAMC,aAAa,GAAGC,gBAAgB,CAACnB,MAAM,CAAC;IAC9C,IAAMoB,UAAU,GAAGF,aAAa,CAACT,OAAO,CAACP,KAAK,CAAC;IAC/C,IAAMmB,cAAc,GAAGD,UAAU,GAAG,CAAC;IACrC,IAAME,SAAS,GAAGJ,aAAa,CAACG,cAAc,CAAC;IAE/C,IAAME,QAAQ,GACZD,SAAS,IAAI,IAAI,IAAItB,MAAM,CAACsB,SAAS,CAAC,CAACX,KAAK,IAAI,IAAI,GAChDX,MAAM,CAACsB,SAAS,CAAC,CAACX,KAAK,GACvBZ,KAAK,CAACK,QAAQ,CAACoB,MAAM;IAC3B,IAAMC,UAAU,GAAGC,YAAY,CAAC3B,KAAK,EAAEkB,IAAI,EAAEM,QAAQ,CAAC;IAEtD,IAAIE,UAAU,EAAE;MAEd,IAAIzB,MAAM,CAACE,KAAK,CAAC,CAACS,KAAK,IAAI,IAAI,EAAE;QAC/BX,MAAM,CAACE,KAAK,CAAC,CAACS,KAAK,GAAGY,QAAQ;MAChC;MAEA,KAAK,IAAIhB,CAAC,GAAGc,cAAc,EAAEd,CAAC,GAAGW,aAAa,CAACM,MAAM,EAAEjB,CAAC,IAAI,CAAC,EAAE;QAC7D,IAAMoB,WAAW,GAAGT,aAAa,CAACX,CAAC,CAAC;QACpC,IAAMqB,aAAa,GAAG5B,MAAM,CAAC2B,WAAW,CAAC,CAAChB,KAAK;QAC/CX,MAAM,CAAC2B,WAAW,CAAC,CAAChB,KAAK,GAAGiB,aAAa,GAAG,CAAC;MAC/C;IACF;IAEA,OAAOH,UAAU;EACnB;EAEA,IAAMI,oBAAoB,GAAG;IAI3BC,cAAc,WAAAA,eAAA,EAAW;MACvB,OAAOX,gBAAgB,CAACnB,MAAM,CAAC,CAC5B+B,GAAG,CAAC,UAAA7B,KAAK,EAAI;QACZ,IAAMU,KAAK,GAAGZ,MAAM,CAACE,KAAK,CAAC,CAACU,KAAK;QACjC,OAAOA,KAAK,CAACoB,IAAI,CAAC,IAAI,CAAC;MACzB,CAAC,CAAC,CACDA,IAAI,CAAC,IAAI,CAAC;IACf,CAAC;IAKDC,MAAM,WAAAA,OAACzB,OAAe,EAAE0B,UAAkB,EAAE;MAC1C,IAAMhC,KAAK,GAAGiC,MAAM,CAACD,UAAU,CAAC;MAGhC,IAAIlC,MAAM,CAACE,KAAK,CAAC,IAAI,IAAI,EAAE;QACzB,IAAMkC,UAAU,GAAGC,eAAe,CAACnC,KAAK,CAAC;QAEzCF,MAAM,CAACE,KAAK,CAAC,GAAG;UAAES,KAAK,EAAE,IAAI;UAAEC,KAAK,EAAE,CAACwB,UAAU;QAAE,CAAC;QAEpD,IAAIrC,KAAK,IAAI,IAAI,EAAE;UACjBiB,WAAW,CAACjB,KAAK,EAAEG,KAAK,EAAEkC,UAAU,CAAC;QACvC;MACF;MAKA,IAAMvB,YAAY,GAAGC,eAAe,CAACN,OAAO,CAAC;MAC7C,IAAIK,YAAY,IAAI,IAAI,IAAIZ,SAAS,CAACY,YAAY,CAAC,IAAI,IAAI,EAAE;QAE3DZ,SAAS,CAACY,YAAY,CAAC,GAAG,IAAI;QAC9Bb,MAAM,CAACE,KAAK,CAAC,CAACU,KAAK,CAACG,IAAI,CAACP,OAAO,CAAC;QAEjC,IAAIT,KAAK,IAAI,IAAI,EAAE;UACjB,IAAM0B,UAAU,GAAGT,WAAW,CAACjB,KAAK,EAAEG,KAAK,EAAEM,OAAO,CAAC;UACrD,IAAI,CAACiB,UAAU,EAAE;YAGfzB,MAAM,CAACE,KAAK,CAAC,CAACU,KAAK,CAAC0B,GAAG,CAAC,CAAC;UAC3B;QACF;MACF;IACF;EACF,CAAC;EAED,OAAOT,oBAAoB;AAC7B;AAMA,SAASQ,eAAeA,CAACnC,KAAK,EAAE;EAC9B,gCAA6BA,KAAK;AACpC;AAEA,SAASQ,eAAeA,CAACJ,OAAO,EAAE;EAChC,OAAO6B,MAAM,CAAC7B,OAAO,CAACO,YAAY,CAAC0B,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACtD;AAEA,SAASpB,gBAAgBA,CAACqB,GAA2B,EAAE;EACrD,OAAOC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CACpBT,GAAG,CAACI,MAAM,CAAC,CACXQ,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAA,OAAMD,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAAA,CAAC,CAAC;AACrC;AAEA,IAAMC,OAAO,GAAG,cAAc;AAC9B,SAAShC,eAAeA,CAACN,OAAO,EAAE;EAChC,IAAMuC,QAAQ,GAAGvC,OAAO,CAAC+B,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACS,IAAI,CAAC,CAAC;EAC7C,OAAOD,QAAQ,KAAK,EAAE,GAAGA,QAAQ,CAACE,OAAO,CAACH,OAAO,EAAE,IAAI,CAAC,GAAG,IAAI;AACjE;AAEA,SAASpB,YAAYA,CAACwB,IAAI,EAAE1C,OAAe,EAAEe,QAAgB,EAAW;EACtE,IAAI;IAEF2B,IAAI,CAACC,UAAU,CAAC3C,OAAO,EAAEe,QAAQ,CAAC;IAClC,OAAO,IAAI;EACb,CAAC,CAAC,OAAO6B,CAAC,EAAE;IAGV,OAAO,KAAK;EACd;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}