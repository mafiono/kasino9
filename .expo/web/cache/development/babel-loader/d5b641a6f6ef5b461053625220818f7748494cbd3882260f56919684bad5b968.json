{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _toArray from \"@babel/runtime/helpers/toArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport pathToRegexp from 'path-to-regexp';\nvar compilePathToRegex = function compilePathToRegex(path) {\n  var keys = [];\n  var re = pathToRegexp(path, keys);\n  return {\n    re: re,\n    keys: keys\n  };\n};\nexport var matchPath = function matchPath(path, url) {\n  var _url$split = url.split('?'),\n    _url$split2 = _slicedToArray(_url$split, 1),\n    urlCleaned = _url$split2[0];\n  var urlToMatch = !urlCleaned.endsWith('/') ? urlCleaned + \"/\" : urlCleaned;\n  var _compilePathToRegex = compilePathToRegex(path),\n    re = _compilePathToRegex.re,\n    keys = _compilePathToRegex.keys;\n  var match = re.exec(urlToMatch);\n  if (!match) {\n    return null;\n  }\n  var _match = _toArray(match),\n    compiledUrl = _match[0],\n    values = _match.slice(1);\n  if (urlToMatch !== compiledUrl) {\n    return null;\n  }\n  var params = keys.reduce(function (acc, key, index) {\n    return _extends({}, acc, _defineProperty({}, key.name, values[index]));\n  }, {});\n  return {\n    path: path,\n    params: params\n  };\n};\nvar pathParser = function pathParser(url) {\n  var possibleMatchingpaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return possibleMatchingpaths.map(function (path) {\n    return matchPath(path, url);\n  }).find(function (obj) {\n    return obj;\n  });\n};\nexport default pathParser;","map":{"version":3,"names":["pathToRegexp","compilePathToRegex","path","keys","re","matchPath","url","_url$split","split","_url$split2","_slicedToArray","urlCleaned","urlToMatch","endsWith","_compilePathToRegex","match","exec","_match","_toArray","compiledUrl","values","slice","params","reduce","acc","key","index","_extends","_defineProperty","name","pathParser","possibleMatchingpaths","arguments","length","undefined","map","find","obj"],"sources":["C:/Users/adamk/Downloads/kasino9/node_modules/react-native-router-flux/src/pathParser.js"],"sourcesContent":["import pathToRegexp from 'path-to-regexp';\n\n/**\n *\n * This set of functions are used to match a url with a uri path.\n * This functionality is based on the internals of React-Router's matchPath.\n * - https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/matchPath.md\n *\n */\n\n/**\n * This function accepts a uri path and returns a regex to match that path\n * against a url and an array of the keys extracted from that uri path\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n *\n * Sample Input: \"/user/:id/\"\n *\n * Sample Output:\n * {\n *     re: /^\\/user\\/([^\\/]+?)\\/(?:\\/(?=$))?/i,\n *     keys: [\n *         name: \"id\"\n *         delimiter: \"/\"\n *         optional: false\n *         partial: false\n *         path: \"[^\\/]+?\"\n *         prefix: \"/\"\n *         repeat: false,\n *     ]\n * }\n */\nconst compilePathToRegex = (path) => {\n  const keys = [];\n  const re = pathToRegexp(path, keys);\n  // Returns the regex path to match a uri path to an actual url\n  // and the keys that can be used to pull values from the url.\n  return { re, keys };\n};\n\n/**\n * This function accepts a uri path and an actual url. It determines whether\n * or not they match one another. If they do not match, the funtion returns null.\n * If they do match, then the function returns the path and the params parsed\n * from the url.\n *\n * @param {String} path - a uri path in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match the given path\n *\n * Case 1 - path Does Not Match Url:\n *   Sample Input: (path: \"/edit/organization/(:id)\", url: \"/user/300002/\")\n *\n *   Sample Output: null\n *\n * Case 2 - path Does Match Url:\n *   Sample Input: (path: \"/user/:id/\", url: \"/user/300002/\")\n *\n *   Sample Output:\n *   {\n *       path: \"/user/:id/\",\n *       params: {\n *           id: \"300002\",\n *       }\n *   }\n *\n */\nexport const matchPath = (path, url) => {\n  // Remove possible query fragments, which are not supported by iOS and some\n  // versions of Anroid.\n  const [urlCleaned] = url.split('?');\n\n  // Append trailing slash for compatibility with pathToRegexp\n  const urlToMatch = !urlCleaned.endsWith('/') ? `${urlCleaned}/` : urlCleaned;\n\n  // Return the regex and the keys that can be parsed from a uri path.\n  const { re, keys } = compilePathToRegex(path);\n\n  // Check if the given url matches the uri path.\n  const match = re.exec(urlToMatch);\n\n  // If there is no match, then return null.\n  if (!match) {\n    return null;\n  }\n\n  // Destructure to return the compiled url (aka the reconstructed url based\n  // on the regex and the url parameters.\n  const [compiledUrl, ...values] = match;\n\n  // If there is an inexact match (aka the compiled path does not match the\n  // given url, then return null)\n  if (urlToMatch !== compiledUrl) {\n    return null;\n  }\n\n  const params = keys.reduce((acc, key, index) => Object.assign({}, acc, { [key.name]: values[index] }), {});\n\n  return { path, params };\n};\n\n/**\n * This function accepts an array of uri paths and a url. If there are no paths\n * in the array that match the given url, then the function will return null.\n * If there is at least one matching uri path, it will return the first\n * matching path and the parsed url parameters (the output from matchPath()).\n *\n * @param {Array} possibleMatchingpaths - an array of uri paths in standard template (https://tools.ietf.org/html/rfc6570)\n * @param {String} url - a url that may or may not match a given path\n *\n */\nconst pathParser = (url, possibleMatchingpaths = []) => possibleMatchingpaths.map(path => matchPath(path, url)).find(obj => obj);\n\nexport default pathParser;\n"],"mappings":";;;;AAAA,OAAOA,YAAY,MAAM,gBAAgB;AAgCzC,IAAMC,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIC,IAAI,EAAK;EACnC,IAAMC,IAAI,GAAG,EAAE;EACf,IAAMC,EAAE,GAAGJ,YAAY,CAACE,IAAI,EAAEC,IAAI,CAAC;EAGnC,OAAO;IAAEC,EAAE,EAAFA,EAAE;IAAED,IAAI,EAAJA;EAAK,CAAC;AACrB,CAAC;AA4BD,OAAO,IAAME,SAAS,GAAG,SAAZA,SAASA,CAAIH,IAAI,EAAEI,GAAG,EAAK;EAAA,IAAAC,UAAA,GAGjBD,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC;IAAAC,WAAA,GAAAC,cAAA,CAAAH,UAAA;IAA5BI,UAAU,GAAAF,WAAA;EAGjB,IAAMG,UAAU,GAAG,CAACD,UAAU,CAACE,QAAQ,CAAC,GAAG,CAAC,GAAMF,UAAU,SAAMA,UAAU;EAAC,IAAAG,mBAAA,GAGxDb,kBAAkB,CAACC,IAAI,CAAC;IAArCE,EAAE,GAAAU,mBAAA,CAAFV,EAAE;IAAED,IAAI,GAAAW,mBAAA,CAAJX,IAAI;EAGhB,IAAMY,KAAK,GAAGX,EAAE,CAACY,IAAI,CAACJ,UAAU,CAAC;EAGjC,IAAI,CAACG,KAAK,EAAE;IACV,OAAO,IAAI;EACb;EAAC,IAAAE,MAAA,GAAAC,QAAA,CAIgCH,KAAK;IAA/BI,WAAW,GAAAF,MAAA;IAAKG,MAAM,GAAAH,MAAA,CAAAI,KAAA;EAI7B,IAAIT,UAAU,KAAKO,WAAW,EAAE;IAC9B,OAAO,IAAI;EACb;EAEA,IAAMG,MAAM,GAAGnB,IAAI,CAACoB,MAAM,CAAC,UAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK;IAAA,OAAKC,QAAA,CAAc,CAAC,CAAC,EAAEH,GAAG,EAAAI,eAAA,KAAKH,GAAG,CAACI,IAAI,EAAGT,MAAM,CAACM,KAAK,CAAC,CAAE,CAAC;EAAA,GAAE,CAAC,CAAC,CAAC;EAE1G,OAAO;IAAExB,IAAI,EAAJA,IAAI;IAAEoB,MAAM,EAANA;EAAO,CAAC;AACzB,CAAC;AAYD,IAAMQ,UAAU,GAAG,SAAbA,UAAUA,CAAIxB,GAAG;EAAA,IAAEyB,qBAAqB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EAAA,OAAKD,qBAAqB,CAACI,GAAG,CAAC,UAAAjC,IAAI;IAAA,OAAIG,SAAS,CAACH,IAAI,EAAEI,GAAG,CAAC;EAAA,EAAC,CAAC8B,IAAI,CAAC,UAAAC,GAAG;IAAA,OAAIA,GAAG;EAAA,EAAC;AAAA;AAEhI,eAAeP,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}