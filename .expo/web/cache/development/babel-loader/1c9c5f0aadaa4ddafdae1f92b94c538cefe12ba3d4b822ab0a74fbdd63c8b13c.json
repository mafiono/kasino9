{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nvar _jsxFileName = \"/Users/satya/Workspace/Callstack/react-navigation-stack/src/views/StackView/StackViewLayout.tsx\";\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { SceneView, StackActions, NavigationActions, NavigationProvider, ThemeContext, withOrientation } from 'react-navigation';\nimport { ScreenContainer } from 'react-native-screens';\nimport { PanGestureHandler, State as GestureState } from 'react-native-gesture-handler';\nimport Card from \"./StackViewCard\";\nimport Header from \"../Header/Header\";\nimport TransitionConfigs from \"./StackViewTransitionConfigs\";\nimport HeaderStyleInterpolator from \"../Header/HeaderStyleInterpolator\";\nimport StackGestureContext from \"../../utils/StackGestureContext\";\nimport clamp from \"../../utils/clamp\";\nimport { supportsImprovedSpringAnimation } from \"../../utils/ReactNativeFeatures\";\nvar IPHONE_XS_HEIGHT = 812;\nvar IPHONE_XR_HEIGHT = 896;\nvar _Dimensions$get = Dimensions.get('window'),\n  WINDOW_WIDTH = _Dimensions$get.width,\n  WINDOW_HEIGHT = _Dimensions$get.height;\nvar IS_IPHONE_X = Platform.OS === 'ios' && !Platform.isPad && !Platform.isTVOS && (WINDOW_HEIGHT === IPHONE_XS_HEIGHT || WINDOW_WIDTH === IPHONE_XS_HEIGHT || WINDOW_HEIGHT === IPHONE_XR_HEIGHT || WINDOW_WIDTH === IPHONE_XR_HEIGHT);\nvar EaseInOut = Easing.inOut(Easing.ease);\nvar HEADER_LAYOUT_PRESET = ['center', 'left'];\nvar HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nvar HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\nvar ANIMATION_DURATION = 500;\nvar POSITION_THRESHOLD = 1 / 2;\nvar GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nvar GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\nvar USE_NATIVE_DRIVER = Platform.OS === 'android' || Platform.OS === 'ios';\nvar getDefaultHeaderHeight = function getDefaultHeaderHeight(isLandscape) {\n  if (Platform.OS === 'ios') {\n    if (isLandscape && !Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else if (Platform.OS === 'android') {\n    return 56;\n  } else {\n    return 64;\n  }\n};\nvar StackViewLayout = function (_React$Component) {\n  _inherits(StackViewLayout, _React$Component);\n  function StackViewLayout(props) {\n    var _this;\n    _classCallCheck(this, StackViewLayout);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(StackViewLayout).call(this, props));\n    _this.immediateIndex = null;\n    _this.handleFloatingHeaderLayout = function (e) {\n      var height = e.nativeEvent.layout.height;\n      if (height !== _this.state.floatingHeaderHeight) {\n        _this.setState({\n          floatingHeaderHeight: height\n        });\n      }\n    };\n    _this.handlePanGestureStateChange = function (_ref) {\n      var nativeEvent = _ref.nativeEvent;\n      if (nativeEvent.oldState === GestureState.ACTIVE) {\n        if (_this.positionSwitch.__getValue() === 1) {\n          return;\n        }\n        if (_this.isMotionVertical()) {\n          _this.handleReleaseVertical(nativeEvent);\n        } else {\n          _this.handleReleaseHorizontal(nativeEvent);\n        }\n      } else if (nativeEvent.state === GestureState.ACTIVE) {\n        _this.props.onGestureBegin && _this.props.onGestureBegin();\n        _this.positionSwitch.setValue(0);\n      }\n    };\n    _this.renderCard = function (scene) {\n      var _this$props = _this.props,\n        transitionProps = _this$props.transitionProps,\n        cardShadowEnabled = _this$props.cardShadowEnabled,\n        cardOverlayEnabled = _this$props.cardOverlayEnabled,\n        transparentCard = _this$props.transparentCard,\n        cardStyle = _this$props.cardStyle;\n      var _ref2 = _this.transitionConfig,\n        screenInterpolator = _ref2.screenInterpolator;\n      var style = screenInterpolator && screenInterpolator(_objectSpread({}, transitionProps, {\n        shadowEnabled: cardShadowEnabled,\n        cardOverlayEnabled: cardOverlayEnabled,\n        position: _this.position,\n        scene: scene\n      }));\n      var options = scene.descriptor.options;\n      var hasHeader = options.header !== null && options.headerShown !== false;\n      var headerMode = _this.getHeaderMode();\n      var floatingContainerStyle = StyleSheet.absoluteFill;\n      if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n        floatingContainerStyle = _objectSpread({}, Platform.select({\n          web: {},\n          default: StyleSheet.absoluteFillObject\n        }), {\n          paddingTop: _this.state.floatingHeaderHeight\n        });\n      }\n      return React.createElement(Card, _extends({}, transitionProps, {\n        key: \"card_\" + scene.key,\n        position: _this.position,\n        realPosition: transitionProps.position,\n        animatedStyle: style,\n        transparent: transparentCard,\n        style: [floatingContainerStyle, cardStyle],\n        scene: scene,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 975\n        }\n      }), _this.renderInnerScene(scene));\n    };\n    _this.panGestureRef = React.createRef();\n    _this.gestureX = new Animated.Value(0);\n    _this.gestureY = new Animated.Value(0);\n    _this.positionSwitch = new Animated.Value(1);\n    if (Animated.subtract) {\n      _this.gestureSwitch = Animated.subtract(1, _this.positionSwitch);\n    } else {\n      _this.gestureSwitch = Animated.add(1, Animated.multiply(-1, _this.positionSwitch));\n    }\n    _this.gestureEvent = Animated.event([{\n      nativeEvent: {\n        translationX: _this.gestureX,\n        translationY: _this.gestureY\n      }\n    }], {\n      useNativeDriver: USE_NATIVE_DRIVER\n    });\n    _this.state = {\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape)\n    };\n    return _this;\n  }\n  _createClass(StackViewLayout, [{\n    key: \"renderHeader\",\n    value: function renderHeader(scene, headerMode) {\n      var options = scene.descriptor.options;\n      var header = options.header,\n        headerShown = options.headerShown;\n      if (__DEV__ && typeof header === 'string') {\n        throw new Error(\"Invalid header value: \\\"\" + header + \"\\\". The header option must be a valid React component or null, not a string.\");\n      }\n      if ((header === null || headerShown === false) && headerMode === 'screen') {\n        return null;\n      }\n      if (React.isValidElement(header)) {\n        return header;\n      }\n      var renderHeader = header || function (props) {\n        return React.createElement(Header, _extends({}, props, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 217\n          }\n        }));\n      };\n      var _ref3 = this.transitionConfig,\n        headerLeftInterpolator = _ref3.headerLeftInterpolator,\n        headerTitleInterpolator = _ref3.headerTitleInterpolator,\n        headerRightInterpolator = _ref3.headerRightInterpolator,\n        headerBackgroundInterpolator = _ref3.headerBackgroundInterpolator;\n      var backgroundTransitionPresetInterpolator = this.getHeaderBackgroundTransitionPreset();\n      if (backgroundTransitionPresetInterpolator) {\n        headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n      }\n      var _this$props2 = this.props,\n        transitionProps = _this$props2.transitionProps,\n        passProps = _objectWithoutProperties(_this$props2, [\"transitionProps\"]);\n      return React.createElement(NavigationProvider, {\n        value: scene.descriptor.navigation,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 234\n        }\n      }, renderHeader(_objectSpread({}, passProps, transitionProps, {\n        position: this.position,\n        scene: scene,\n        mode: headerMode,\n        transitionPreset: this.getHeaderTransitionPreset(),\n        layoutPreset: this.getHeaderLayoutPreset(),\n        backTitleVisible: this.getHeaderBackTitleVisible(),\n        leftInterpolator: headerLeftInterpolator,\n        titleInterpolator: headerTitleInterpolator,\n        rightInterpolator: headerRightInterpolator,\n        backgroundInterpolator: headerBackgroundInterpolator\n      })));\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(resetToIndex, duration) {\n      if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n        Animated.spring(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          stiffness: 6000,\n          damping: 100,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      } else {\n        Animated.timing(this.props.transitionProps.position, {\n          toValue: resetToIndex,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start();\n      }\n    }\n  }, {\n    key: \"goBack\",\n    value: function goBack(backFromIndex, duration) {\n      var _this2 = this;\n      var _this$props$transitio = this.props.transitionProps,\n        navigation = _this$props$transitio.navigation,\n        position = _this$props$transitio.position,\n        scenes = _this$props$transitio.scenes;\n      var toValue = Math.max(backFromIndex - 1, 0);\n      this.immediateIndex = toValue;\n      var onCompleteAnimation = function onCompleteAnimation() {\n        _this2.immediateIndex = null;\n        var backFromScene = scenes.find(function (s) {\n          return s.index === toValue + 1;\n        });\n        if (backFromScene) {\n          navigation.dispatch(NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true\n          }));\n          navigation.dispatch(StackActions.completeTransition());\n        }\n      };\n      if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n        Animated.spring(position, {\n          toValue: toValue,\n          stiffness: 7000,\n          damping: 300,\n          mass: 3,\n          overshootClamping: true,\n          restDisplacementThreshold: 0.01,\n          restSpeedThreshold: 0.01,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      } else {\n        Animated.timing(position, {\n          toValue: toValue,\n          duration: duration,\n          easing: EaseInOut,\n          useNativeDriver: USE_NATIVE_DRIVER\n        }).start(onCompleteAnimation);\n      }\n    }\n  }, {\n    key: \"prepareAnimated\",\n    value: function prepareAnimated() {\n      if (this.props === this.prevProps) {\n        return;\n      }\n      this.prevProps = this.props;\n      this.prepareGesture();\n      this.preparePosition();\n      this.prepareTransitionConfig();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.prepareAnimated();\n      var transitionProps = this.props.transitionProps;\n      var index = transitionProps.navigation.state.index,\n        scenes = transitionProps.scenes;\n      var headerMode = this.getHeaderMode();\n      var floatingHeader = null;\n      if (headerMode === 'float') {\n        var scene = transitionProps.scene;\n        floatingHeader = React.createElement(View, {\n          style: styles.floatingHeader,\n          pointerEvents: \"box-none\",\n          onLayout: this.handleFloatingHeaderLayout,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 356\n          }\n        }, this.renderHeader(scene, headerMode));\n      }\n      return React.createElement(PanGestureHandler, _extends({}, this.gestureActivationCriteria(), {\n        ref: this.panGestureRef,\n        onGestureEvent: this.gestureEvent,\n        onHandlerStateChange: this.handlePanGestureStateChange,\n        enabled: index > 0 && this.isGestureEnabled(),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 367\n        }\n      }), React.createElement(Animated.View, {\n        style: [styles.container, this.context === 'light' ? this.transitionConfig.containerStyleLight : this.transitionConfig.containerStyleDark, this.transitionConfig.containerStyle],\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 374\n        }\n      }, React.createElement(StackGestureContext.Provider, {\n        value: this.panGestureRef,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 383\n        }\n      }, React.createElement(ScreenContainer, {\n        style: styles.scenes,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 384\n        }\n      }, scenes.map(this.renderCard)), floatingHeader)));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var prevState = prevProps.transitionProps.navigation.state;\n      var state = this.props.transitionProps.navigation.state;\n      if (prevState.index !== state.index) {\n        this.maybeCancelGesture();\n      }\n    }\n  }, {\n    key: \"getGestureResponseDistance\",\n    value: function getGestureResponseDistance() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var _options$gestureRespo = options.gestureResponseDistance,\n        userGestureResponseDistance = _options$gestureRespo === void 0 ? {} : _options$gestureRespo;\n      return this.isModal() ? userGestureResponseDistance.vertical || GESTURE_RESPONSE_DISTANCE_VERTICAL : userGestureResponseDistance.horizontal || GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n    }\n  }, {\n    key: \"gestureActivationCriteria\",\n    value: function gestureActivationCriteria() {\n      var layout = this.props.transitionProps.layout;\n      var gestureResponseDistance = this.getGestureResponseDistance();\n      var isMotionInverted = this.isMotionInverted();\n      if (this.isMotionVertical()) {\n        var height = layout.height.__getValue();\n        return {\n          maxDeltaX: 15,\n          minOffsetY: isMotionInverted ? -5 : 5,\n          hitSlop: isMotionInverted ? {\n            top: -height + gestureResponseDistance\n          } : {\n            bottom: -height + gestureResponseDistance\n          }\n        };\n      } else {\n        var width = layout.width.__getValue();\n        var hitSlop = -width + gestureResponseDistance;\n        return {\n          minOffsetX: isMotionInverted ? -5 : 5,\n          maxDeltaY: 20,\n          hitSlop: isMotionInverted ? {\n            left: hitSlop\n          } : {\n            right: hitSlop\n          }\n        };\n      }\n    }\n  }, {\n    key: \"isGestureEnabled\",\n    value: function isGestureEnabled() {\n      var gesturesEnabled = this.props.transitionProps.scene.descriptor.options.gesturesEnabled;\n      return typeof gesturesEnabled === 'boolean' ? gesturesEnabled : Platform.OS === 'ios';\n    }\n  }, {\n    key: \"isMotionVertical\",\n    value: function isMotionVertical() {\n      return this.isModal();\n    }\n  }, {\n    key: \"isModal\",\n    value: function isModal() {\n      return this.props.mode === 'modal';\n    }\n  }, {\n    key: \"isMotionInverted\",\n    value: function isMotionInverted() {\n      var scene = this.props.transitionProps.scene;\n      var options = scene.descriptor.options;\n      var gestureDirection = options.gestureDirection;\n      if (this.isModal()) {\n        return gestureDirection === 'inverted';\n      } else {\n        return typeof gestureDirection === 'string' ? gestureDirection === 'inverted' : I18nManager.isRTL;\n      }\n    }\n  }, {\n    key: \"computeHorizontalGestureValue\",\n    value: function computeHorizontalGestureValue(_ref4) {\n      var translationX = _ref4.translationX;\n      var _this$props$transitio2 = this.props.transitionProps,\n        navigation = _this$props$transitio2.navigation,\n        layout = _this$props$transitio2.layout;\n      var index = navigation.state.index;\n      var distance = layout.width.__getValue();\n      var x = this.isMotionInverted() ? -1 * translationX : translationX;\n      var value = index - x / distance;\n      return clamp(index - 1, value, index);\n    }\n  }, {\n    key: \"computeVerticalGestureValue\",\n    value: function computeVerticalGestureValue(_ref5) {\n      var translationY = _ref5.translationY;\n      var _this$props$transitio3 = this.props.transitionProps,\n        navigation = _this$props$transitio3.navigation,\n        layout = _this$props$transitio3.layout;\n      var index = navigation.state.index;\n      var distance = layout.height.__getValue();\n      var y = this.isMotionInverted() ? -1 * translationY : translationY;\n      var value = index - y / distance;\n      return clamp(index - 1, value, index);\n    }\n  }, {\n    key: \"maybeCancelGesture\",\n    value: function maybeCancelGesture() {\n      this.positionSwitch.setValue(1);\n    }\n  }, {\n    key: \"prepareGesture\",\n    value: function prepareGesture() {\n      if (!this.isGestureEnabled()) {\n        if (this.positionSwitch.__getValue() !== 1) {\n          this.positionSwitch.setValue(1);\n        }\n        this.gesturePosition = undefined;\n        return;\n      }\n      if (this.props.transitionProps.layout.width.__getValue() === 0 || this.props.transitionProps.layout.height.__getValue() === 0) {\n        return;\n      }\n      if (this.isMotionVertical()) {\n        this.prepareGestureVertical();\n      } else {\n        this.prepareGestureHorizontal();\n      }\n    }\n  }, {\n    key: \"prepareGestureHorizontal\",\n    value: function prepareGestureHorizontal() {\n      var index = this.props.transitionProps.navigation.state.index;\n      if (this.isMotionInverted()) {\n        this.gesturePosition = Animated.add(index, Animated.divide(this.gestureX, this.props.transitionProps.layout.width)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = Animated.add(index, Animated.multiply(-1, Animated.divide(this.gestureX, this.props.transitionProps.layout.width))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"prepareGestureVertical\",\n    value: function prepareGestureVertical() {\n      var index = this.props.transitionProps.navigation.state.index;\n      if (this.isMotionInverted()) {\n        this.gesturePosition = Animated.add(index, Animated.divide(this.gestureY, this.props.transitionProps.layout.height)).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      } else {\n        this.gesturePosition = Animated.add(index, Animated.multiply(-1, Animated.divide(this.gestureY, this.props.transitionProps.layout.height))).interpolate({\n          inputRange: [index - 1, index],\n          outputRange: [index - 1, index],\n          extrapolate: 'clamp'\n        });\n      }\n    }\n  }, {\n    key: \"handleReleaseHorizontal\",\n    value: function handleReleaseHorizontal(nativeEvent) {\n      var _this$props$transitio4 = this.props.transitionProps,\n        navigation = _this$props$transitio4.navigation,\n        position = _this$props$transitio4.position,\n        layout = _this$props$transitio4.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this.immediateIndex == null ? index : this.immediateIndex;\n      var distance = layout.width.__getValue();\n      var movementDirection = this.isMotionInverted() ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationX;\n      var gestureVelocity = movementDirection * nativeEvent.velocityX;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = this.isMotionInverted() ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = this.isMotionInverted() ? movedDistance / velocity : (distance - movedDistance) / velocity;\n      var value = this.computeHorizontalGestureValue(nativeEvent);\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n        return;\n      }\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n        return;\n      }\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"handleReleaseVertical\",\n    value: function handleReleaseVertical(nativeEvent) {\n      var _this$props$transitio5 = this.props.transitionProps,\n        navigation = _this$props$transitio5.navigation,\n        position = _this$props$transitio5.position,\n        layout = _this$props$transitio5.layout;\n      var index = navigation.state.index;\n      var immediateIndex = this.immediateIndex == null ? index : this.immediateIndex;\n      var distance = layout.height.__getValue();\n      var isMotionInverted = this.isMotionInverted();\n      var movementDirection = isMotionInverted ? -1 : 1;\n      var movedDistance = movementDirection * nativeEvent.translationY;\n      var gestureVelocity = movementDirection * nativeEvent.velocityY;\n      var defaultVelocity = distance / ANIMATION_DURATION;\n      var velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n      var resetDuration = isMotionInverted ? (distance - movedDistance) / velocity : movedDistance / velocity;\n      var goBackDuration = isMotionInverted ? movedDistance / velocity : (distance - movedDistance) / velocity;\n      var value = this.computeVerticalGestureValue(nativeEvent);\n      position.setValue(value);\n      this.positionSwitch.setValue(1);\n      if (gestureVelocity < -50) {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n        return;\n      }\n      if (gestureVelocity > 50) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n        return;\n      }\n      if (value <= index - POSITION_THRESHOLD) {\n        this.props.onGestureEnd && this.props.onGestureEnd();\n        this.goBack(immediateIndex, goBackDuration);\n      } else {\n        this.props.onGestureCanceled && this.props.onGestureCanceled();\n        this.reset(immediateIndex, resetDuration);\n      }\n    }\n  }, {\n    key: \"getHeaderMode\",\n    value: function getHeaderMode() {\n      if (this.props.headerMode) {\n        return this.props.headerMode;\n      }\n      if (Platform.OS === 'android' || this.props.mode === 'modal') {\n        return 'screen';\n      }\n      return 'float';\n    }\n  }, {\n    key: \"getHeaderBackgroundTransitionPreset\",\n    value: function getHeaderBackgroundTransitionPreset() {\n      var headerBackgroundTransitionPreset = this.props.headerBackgroundTransitionPreset;\n      if (headerBackgroundTransitionPreset) {\n        if (HEADER_BACKGROUND_TRANSITION_PRESET.includes(headerBackgroundTransitionPreset)) {\n          if (headerBackgroundTransitionPreset === 'fade') {\n            return HeaderStyleInterpolator.forBackgroundWithFade;\n          } else if (headerBackgroundTransitionPreset === 'translate') {\n            return HeaderStyleInterpolator.forBackgroundWithTranslation;\n          } else if (headerBackgroundTransitionPreset === 'toggle') {\n            return HeaderStyleInterpolator.forBackgroundWithInactiveHidden;\n          }\n        } else if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerBackgroundTransitionPreset - expected one of \" + HEADER_BACKGROUND_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerBackgroundTransitionPreset));\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"getHeaderLayoutPreset\",\n    value: function getHeaderLayoutPreset() {\n      var headerLayoutPreset = this.props.headerLayoutPreset;\n      if (headerLayoutPreset) {\n        if (__DEV__) {\n          if (this.getHeaderTransitionPreset() === 'uikit' && headerLayoutPreset === 'left' && Platform.OS === 'ios') {\n            console.warn(\"headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'\");\n          }\n        }\n        if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n          return headerLayoutPreset;\n        }\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerLayoutPreset - expected one of \" + HEADER_LAYOUT_PRESET.join(', ') + \" but received \" + JSON.stringify(headerLayoutPreset));\n        }\n      }\n      if (Platform.OS !== 'ios') {\n        return 'left';\n      } else {\n        return 'center';\n      }\n    }\n  }, {\n    key: \"getHeaderTransitionPreset\",\n    value: function getHeaderTransitionPreset() {\n      if (Platform.OS !== 'ios' || this.getHeaderMode() === 'screen') {\n        return 'fade-in-place';\n      }\n      var headerTransitionPreset = this.props.headerTransitionPreset;\n      if (headerTransitionPreset) {\n        if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n          return headerTransitionPreset;\n        }\n        if (__DEV__) {\n          console.error(\"Invalid configuration applied for headerTransitionPreset - expected one of \" + HEADER_TRANSITION_PRESET.join(', ') + \" but received \" + JSON.stringify(headerTransitionPreset));\n        }\n      }\n      return 'fade-in-place';\n    }\n  }, {\n    key: \"getHeaderBackTitleVisible\",\n    value: function getHeaderBackTitleVisible() {\n      var headerBackTitleVisible = this.props.headerBackTitleVisible;\n      var layoutPreset = this.getHeaderLayoutPreset();\n      var enabledByDefault = !(layoutPreset === 'left' || Platform.OS !== 'ios');\n      return typeof headerBackTitleVisible === 'boolean' ? headerBackTitleVisible : enabledByDefault;\n    }\n  }, {\n    key: \"renderInnerScene\",\n    value: function renderInnerScene(scene) {\n      var _scene$descriptor = scene.descriptor,\n        navigation = _scene$descriptor.navigation,\n        getComponent = _scene$descriptor.getComponent;\n      var SceneComponent = getComponent();\n      var screenProps = this.props.screenProps;\n      var headerMode = this.getHeaderMode();\n      if (headerMode === 'screen') {\n        return React.createElement(View, {\n          style: styles.container,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 887\n          }\n        }, React.createElement(View, {\n          style: styles.scenes,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 888\n          }\n        }, React.createElement(SceneView, {\n          screenProps: screenProps,\n          navigation: navigation,\n          component: SceneComponent,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 889\n          }\n        })), this.renderHeader(scene, headerMode));\n      }\n      return React.createElement(SceneView, {\n        screenProps: screenProps,\n        navigation: navigation,\n        component: SceneComponent,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 900\n        }\n      });\n    }\n  }, {\n    key: \"prepareTransitionConfig\",\n    value: function prepareTransitionConfig() {\n      this.transitionConfig = TransitionConfigs.getTransitionConfig(this.props.transitionConfig, _objectSpread({}, this.props.transitionProps, {\n        position: this.position\n      }), this.props.lastTransitionProps, this.isModal());\n    }\n  }, {\n    key: \"preparePosition\",\n    value: function preparePosition() {\n      if (this.gesturePosition) {\n        this.position = Animated.add(Animated.multiply(this.props.transitionProps.position, this.positionSwitch), Animated.multiply(this.gesturePosition, this.gestureSwitch));\n      } else {\n        this.position = this.props.transitionProps.position;\n      }\n    }\n  }]);\n  return StackViewLayout;\n}(React.Component);\nStackViewLayout.contextType = ThemeContext;\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column-reverse',\n    overflow: 'hidden'\n  },\n  scenes: {\n    flex: 1\n  },\n  floatingHeader: {\n    position: Platform.select({\n      default: 'absolute',\n      web: 'fixed'\n    }),\n    left: 0,\n    top: 0,\n    right: 0\n  }\n});\nexport default withOrientation(StackViewLayout);","map":{"version":3,"names":["React","Animated","StyleSheet","Platform","View","I18nManager","Easing","Dimensions","SceneView","StackActions","NavigationActions","NavigationProvider","ThemeContext","withOrientation","ScreenContainer","PanGestureHandler","State","GestureState","Card","Header","TransitionConfigs","HeaderStyleInterpolator","StackGestureContext","clamp","supportsImprovedSpringAnimation","IPHONE_XS_HEIGHT","IPHONE_XR_HEIGHT","get","WINDOW_WIDTH","width","WINDOW_HEIGHT","height","IS_IPHONE_X","OS","isPad","isTVOS","EaseInOut","inOut","ease","HEADER_LAYOUT_PRESET","HEADER_TRANSITION_PRESET","HEADER_BACKGROUND_TRANSITION_PRESET","ANIMATION_DURATION","POSITION_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","USE_NATIVE_DRIVER","getDefaultHeaderHeight","isLandscape","StackViewLayout","props","_this","_classCallCheck","_possibleConstructorReturn","_getPrototypeOf","call","immediateIndex","handleFloatingHeaderLayout","e","nativeEvent","layout","state","floatingHeaderHeight","setState","handlePanGestureStateChange","_ref","oldState","ACTIVE","positionSwitch","__getValue","isMotionVertical","handleReleaseVertical","handleReleaseHorizontal","onGestureBegin","setValue","renderCard","scene","_this$props","transitionProps","cardShadowEnabled","cardOverlayEnabled","transparentCard","cardStyle","_ref2","transitionConfig","screenInterpolator","style","_objectSpread","shadowEnabled","position","options","descriptor","hasHeader","header","headerShown","headerMode","getHeaderMode","floatingContainerStyle","absoluteFill","headerTransparent","select","web","default","absoluteFillObject","paddingTop","createElement","_extends","key","realPosition","animatedStyle","transparent","__source","fileName","_jsxFileName","lineNumber","renderInnerScene","panGestureRef","createRef","gestureX","Value","gestureY","subtract","gestureSwitch","add","multiply","gestureEvent","event","translationX","translationY","useNativeDriver","__DEV__","Error","isValidElement","renderHeader","_ref3","headerLeftInterpolator","headerTitleInterpolator","headerRightInterpolator","headerBackgroundInterpolator","backgroundTransitionPresetInterpolator","getHeaderBackgroundTransitionPreset","_this$props2","passProps","_objectWithoutProperties","value","navigation","mode","transitionPreset","getHeaderTransitionPreset","layoutPreset","getHeaderLayoutPreset","backTitleVisible","getHeaderBackTitleVisible","leftInterpolator","titleInterpolator","rightInterpolator","backgroundInterpolator","resetToIndex","duration","spring","toValue","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","start","timing","easing","backFromIndex","_this2","_this$props$transitio","scenes","Math","max","onCompleteAnimation","backFromScene","find","s","index","dispatch","back","route","immediate","completeTransition","prevProps","prepareGesture","preparePosition","prepareTransitionConfig","prepareAnimated","floatingHeader","styles","pointerEvents","onLayout","gestureActivationCriteria","ref","onGestureEvent","onHandlerStateChange","enabled","isGestureEnabled","container","context","containerStyleLight","containerStyleDark","containerStyle","Provider","map","prevState","maybeCancelGesture","_options$gestureRespo","gestureResponseDistance","userGestureResponseDistance","isModal","vertical","horizontal","getGestureResponseDistance","isMotionInverted","maxDeltaX","minOffsetY","hitSlop","top","bottom","minOffsetX","maxDeltaY","left","right","gesturesEnabled","gestureDirection","isRTL","_ref4","_this$props$transitio2","distance","x","_ref5","_this$props$transitio3","y","gesturePosition","undefined","prepareGestureVertical","prepareGestureHorizontal","divide","interpolate","inputRange","outputRange","extrapolate","_this$props$transitio4","movementDirection","movedDistance","gestureVelocity","velocityX","defaultVelocity","velocity","abs","resetDuration","goBackDuration","computeHorizontalGestureValue","onGestureCanceled","reset","onGestureEnd","goBack","_this$props$transitio5","velocityY","computeVerticalGestureValue","headerBackgroundTransitionPreset","includes","forBackgroundWithFade","forBackgroundWithTranslation","forBackgroundWithInactiveHidden","console","error","join","JSON","stringify","headerLayoutPreset","warn","headerTransitionPreset","headerBackTitleVisible","enabledByDefault","_scene$descriptor","getComponent","SceneComponent","screenProps","component","getTransitionConfig","lastTransitionProps","Component","contextType","create","flex","flexDirection","overflow"],"sources":["C:\\Users\\adamk\\Downloads\\kasino9\\node_modules\\react-navigation-stack\\lib\\module\\views\\StackView\\StackViewLayout.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  Platform,\n  View,\n  I18nManager,\n  Easing,\n  Dimensions,\n  ViewStyle,\n  LayoutChangeEvent,\n} from 'react-native';\nimport {\n  SceneView,\n  StackActions,\n  NavigationActions,\n  NavigationProvider,\n  ThemeContext,\n  withOrientation,\n} from 'react-navigation';\nimport { ScreenContainer } from 'react-native-screens';\nimport {\n  PanGestureHandler,\n  State as GestureState,\n  PanGestureHandlerGestureEvent,\n  GestureHandlerGestureEventNativeEvent,\n  PanGestureHandlerEventExtra,\n} from 'react-native-gesture-handler';\n\nimport Card from './StackViewCard';\nimport Header from '../Header/Header';\nimport TransitionConfigs from './StackViewTransitionConfigs';\nimport HeaderStyleInterpolator from '../Header/HeaderStyleInterpolator';\nimport StackGestureContext from '../../utils/StackGestureContext';\nimport clamp from '../../utils/clamp';\nimport { supportsImprovedSpringAnimation } from '../../utils/ReactNativeFeatures';\nimport {\n  Scene,\n  HeaderMode,\n  TransitionProps,\n  TransitionConfig,\n  HeaderTransitionConfig,\n  HeaderProps,\n  NavigationStackConfig,\n} from '../../types';\n\ntype Props = NavigationStackConfig & {\n  isLandscape: boolean;\n  transitionProps: TransitionProps;\n  lastTransitionProps?: TransitionProps;\n  transitionConfig?: (\n    transitionProps: TransitionProps,\n    prevTransitionProps?: TransitionProps,\n    isModal?: boolean\n  ) => TransitionConfig;\n  onGestureBegin?: () => void;\n  onGestureEnd?: () => void;\n  onGestureCanceled?: () => void;\n  screenProps?: unknown;\n};\n\ntype State = {\n  floatingHeaderHeight: number;\n};\n\nconst IPHONE_XS_HEIGHT = 812; // iPhone X and XS\nconst IPHONE_XR_HEIGHT = 896; // iPhone XR and XS Max\nconst { width: WINDOW_WIDTH, height: WINDOW_HEIGHT } = Dimensions.get('window');\nconst IS_IPHONE_X =\n  Platform.OS === 'ios' &&\n  // @ts-ignore\n  !Platform.isPad &&\n  // @ts-ignore\n  !Platform.isTVOS &&\n  (WINDOW_HEIGHT === IPHONE_XS_HEIGHT ||\n    WINDOW_WIDTH === IPHONE_XS_HEIGHT ||\n    WINDOW_HEIGHT === IPHONE_XR_HEIGHT ||\n    WINDOW_WIDTH === IPHONE_XR_HEIGHT);\n\nconst EaseInOut = Easing.inOut(Easing.ease);\n\n/**\n * Enumerate possible values for validation\n */\nconst HEADER_LAYOUT_PRESET = ['center', 'left'];\nconst HEADER_TRANSITION_PRESET = ['fade-in-place', 'uikit'];\nconst HEADER_BACKGROUND_TRANSITION_PRESET = ['toggle', 'fade', 'translate'];\n\n/**\n * The max duration of the card animation in milliseconds after released gesture.\n * The actual duration should be always less then that because the rest distance\n * is always less then the full distance of the layout.\n */\nconst ANIMATION_DURATION = 500;\n\n/**\n * The gesture distance threshold to trigger the back behavior. For instance,\n * `1/2` means that moving greater than 1/2 of the width of the screen will\n * trigger a back action\n */\nconst POSITION_THRESHOLD = 1 / 2;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst USE_NATIVE_DRIVER = Platform.OS === 'android' || Platform.OS === 'ios';\n\nconst getDefaultHeaderHeight = (isLandscape: boolean) => {\n  if (Platform.OS === 'ios') {\n    // @ts-ignore\n    if (isLandscape && !Platform.isPad) {\n      return 32;\n    } else if (IS_IPHONE_X) {\n      return 88;\n    } else {\n      return 64;\n    }\n  } else if (Platform.OS === 'android') {\n    return 56;\n  } else {\n    return 64;\n  }\n};\n\nclass StackViewLayout extends React.Component<Props, State> {\n  static contextType = ThemeContext;\n\n  context!: React.ContextType<typeof ThemeContext>;\n\n  private panGestureRef: React.RefObject<PanGestureHandler>;\n  private gestureX: Animated.Value;\n  private gestureY: Animated.Value;\n  private positionSwitch: Animated.Value;\n  private gestureSwitch: Animated.AnimatedInterpolation;\n  private gestureEvent: (...args: any[]) => void;\n  private gesturePosition: Animated.AnimatedInterpolation | undefined;\n\n  // @ts-ignore\n  private position: Animated.Value;\n\n  /**\n   * immediateIndex is used to represent the expected index that we will be on after a\n   * transition. To achieve a smooth animation when swiping back, the action to go back\n   * doesn't actually fire until the transition completes. The immediateIndex is used during\n   * the transition so that gestures can be handled correctly. This is a work-around for\n   * cases when the user quickly swipes back several times.\n   */\n  private immediateIndex: number | null = null;\n  private transitionConfig:\n    | HeaderTransitionConfig & TransitionConfig\n    | undefined;\n  private prevProps: Props | undefined;\n\n  constructor(props: Props) {\n    super(props);\n    this.panGestureRef = React.createRef();\n    this.gestureX = new Animated.Value(0);\n    this.gestureY = new Animated.Value(0);\n    this.positionSwitch = new Animated.Value(1);\n    if (Animated.subtract) {\n      this.gestureSwitch = Animated.subtract(1, this.positionSwitch);\n    } else {\n      this.gestureSwitch = Animated.add(\n        1,\n        Animated.multiply(-1, this.positionSwitch)\n      );\n    }\n    this.gestureEvent = Animated.event(\n      [\n        {\n          nativeEvent: {\n            translationX: this.gestureX,\n            translationY: this.gestureY,\n          },\n        },\n      ],\n      {\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }\n    );\n\n    this.state = {\n      // Used when card's header is null and mode is float to make transition\n      // between screens with headers and those without headers smooth.\n      // This is not a great heuristic here. We don't know synchronously\n      // on mount what the header height is so we have just used the most\n      // common cases here.\n      floatingHeaderHeight: getDefaultHeaderHeight(props.isLandscape),\n    };\n  }\n\n  private renderHeader(scene: Scene, headerMode: HeaderMode) {\n    const { options } = scene.descriptor;\n    const { header, headerShown } = options;\n\n    if (__DEV__ && typeof header === 'string') {\n      throw new Error(\n        `Invalid header value: \"${header}\". The header option must be a valid React component or null, not a string.`\n      );\n    }\n\n    if ((header === null || headerShown === false) && headerMode === 'screen') {\n      return null;\n    }\n\n    // check if it's a react element\n    if (React.isValidElement(header)) {\n      return header;\n    }\n\n    // Handle the case where the header option is a function, and provide the default\n    const renderHeader =\n      // @ts-ignore TS warns about missing props, but they are in default props\n      header || ((props: HeaderProps) => <Header {...props} />);\n\n    let {\n      headerLeftInterpolator,\n      headerTitleInterpolator,\n      headerRightInterpolator,\n      headerBackgroundInterpolator,\n    } = this.transitionConfig as HeaderTransitionConfig;\n\n    const backgroundTransitionPresetInterpolator = this.getHeaderBackgroundTransitionPreset();\n    if (backgroundTransitionPresetInterpolator) {\n      headerBackgroundInterpolator = backgroundTransitionPresetInterpolator;\n    }\n\n    const { transitionProps, ...passProps } = this.props;\n\n    return (\n      <NavigationProvider value={scene.descriptor.navigation}>\n        {renderHeader({\n          ...passProps,\n          ...transitionProps,\n          position: this.position,\n          scene,\n          mode: headerMode,\n          transitionPreset: this.getHeaderTransitionPreset(),\n          layoutPreset: this.getHeaderLayoutPreset(),\n          backTitleVisible: this.getHeaderBackTitleVisible(),\n          leftInterpolator: headerLeftInterpolator,\n          titleInterpolator: headerTitleInterpolator,\n          rightInterpolator: headerRightInterpolator,\n          backgroundInterpolator: headerBackgroundInterpolator,\n        })}\n      </NavigationProvider>\n    );\n  }\n\n  private reset(resetToIndex: number, duration: number) {\n    if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n      // @ts-ignore\n      Animated.spring(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        stiffness: 6000,\n        damping: 100,\n        mass: 3,\n        overshootClamping: true,\n        restDisplacementThreshold: 0.01,\n        restSpeedThreshold: 0.01,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start();\n    } else {\n      // @ts-ignore\n      Animated.timing(this.props.transitionProps.position, {\n        toValue: resetToIndex,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start();\n    }\n  }\n\n  private goBack(backFromIndex: number, duration: number) {\n    const { navigation, position, scenes } = this.props.transitionProps;\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this.immediateIndex = toValue;\n\n    const onCompleteAnimation = () => {\n      this.immediateIndex = null;\n      const backFromScene = scenes.find(s => s.index === toValue + 1);\n      if (backFromScene) {\n        navigation.dispatch(\n          NavigationActions.back({\n            key: backFromScene.route.key,\n            immediate: true,\n          })\n        );\n        navigation.dispatch(StackActions.completeTransition());\n      }\n    };\n\n    if (Platform.OS === 'ios' && supportsImprovedSpringAnimation()) {\n      // @ts-ignore\n      Animated.spring(position, {\n        toValue,\n        stiffness: 7000,\n        damping: 300,\n        mass: 3,\n        overshootClamping: true,\n        restDisplacementThreshold: 0.01,\n        restSpeedThreshold: 0.01,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start(onCompleteAnimation);\n    } else {\n      // @ts-ignore\n      Animated.timing(position, {\n        toValue,\n        duration,\n        easing: EaseInOut,\n        useNativeDriver: USE_NATIVE_DRIVER,\n      }).start(onCompleteAnimation);\n    }\n  }\n\n  private handleFloatingHeaderLayout = (e: LayoutChangeEvent) => {\n    const { height } = e.nativeEvent.layout;\n    if (height !== this.state.floatingHeaderHeight) {\n      this.setState({ floatingHeaderHeight: height });\n    }\n  };\n\n  private prepareAnimated() {\n    if (this.props === this.prevProps) {\n      return;\n    }\n    this.prevProps = this.props;\n\n    this.prepareGesture();\n    this.preparePosition();\n    this.prepareTransitionConfig();\n  }\n\n  render() {\n    this.prepareAnimated();\n\n    const { transitionProps } = this.props;\n    const {\n      navigation: {\n        state: { index },\n      },\n      scenes,\n    } = transitionProps;\n\n    const headerMode = this.getHeaderMode();\n    let floatingHeader = null;\n    if (headerMode === 'float') {\n      const { scene } = transitionProps;\n      floatingHeader = (\n        <View\n          style={styles.floatingHeader}\n          pointerEvents=\"box-none\"\n          onLayout={this.handleFloatingHeaderLayout}\n        >\n          {this.renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n\n    return (\n      <PanGestureHandler\n        {...this.gestureActivationCriteria()}\n        ref={this.panGestureRef}\n        onGestureEvent={this.gestureEvent}\n        onHandlerStateChange={this.handlePanGestureStateChange}\n        enabled={index > 0 && this.isGestureEnabled()}\n      >\n        <Animated.View\n          style={[\n            styles.container,\n            this.context === 'light'\n              ? this.transitionConfig!.containerStyleLight\n              : this.transitionConfig!.containerStyleDark,\n            this.transitionConfig!.containerStyle,\n          ]}\n        >\n          <StackGestureContext.Provider value={this.panGestureRef}>\n            <ScreenContainer style={styles.scenes}>\n              {scenes.map(this.renderCard)}\n            </ScreenContainer>\n            {floatingHeader}\n          </StackGestureContext.Provider>\n        </Animated.View>\n      </PanGestureHandler>\n    );\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const { state: prevState } = prevProps.transitionProps.navigation;\n    const { state } = this.props.transitionProps.navigation;\n    if (prevState.index !== state.index) {\n      this.maybeCancelGesture();\n    }\n  }\n\n  private getGestureResponseDistance() {\n    const { scene } = this.props.transitionProps;\n    const { options } = scene.descriptor;\n    const {\n      gestureResponseDistance: userGestureResponseDistance = {} as {\n        vertical?: number;\n        horizontal?: number;\n      },\n    } = options;\n\n    // Doesn't make sense for a response distance of 0, so this works fine\n    return this.isModal()\n      ? userGestureResponseDistance.vertical ||\n          GESTURE_RESPONSE_DISTANCE_VERTICAL\n      : userGestureResponseDistance.horizontal ||\n          GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n  }\n\n  private gestureActivationCriteria() {\n    const { layout } = this.props.transitionProps;\n    const gestureResponseDistance = this.getGestureResponseDistance();\n    const isMotionInverted = this.isMotionInverted();\n\n    if (this.isMotionVertical()) {\n      // @ts-ignore\n      const height: number = layout.height.__getValue();\n\n      return {\n        maxDeltaX: 15,\n        minOffsetY: isMotionInverted ? -5 : 5,\n        hitSlop: isMotionInverted\n          ? { top: -height + gestureResponseDistance }\n          : { bottom: -height + gestureResponseDistance },\n      };\n    } else {\n      // @ts-ignore\n      const width: number = layout.width.__getValue();\n      const hitSlop = -width + gestureResponseDistance;\n\n      return {\n        minOffsetX: isMotionInverted ? -5 : 5,\n        maxDeltaY: 20,\n        hitSlop: isMotionInverted ? { left: hitSlop } : { right: hitSlop },\n      };\n    }\n  }\n\n  private isGestureEnabled() {\n    const gesturesEnabled = this.props.transitionProps.scene.descriptor.options\n      .gesturesEnabled;\n    return typeof gesturesEnabled === 'boolean'\n      ? gesturesEnabled\n      : Platform.OS === 'ios';\n  }\n\n  private isMotionVertical() {\n    return this.isModal();\n  }\n\n  private isModal() {\n    return this.props.mode === 'modal';\n  }\n\n  // This only currently applies to the horizontal gesture!\n  private isMotionInverted() {\n    const {\n      transitionProps: { scene },\n    } = this.props;\n    const { options } = scene.descriptor;\n    const { gestureDirection } = options;\n\n    if (this.isModal()) {\n      return gestureDirection === 'inverted';\n    } else {\n      return typeof gestureDirection === 'string'\n        ? gestureDirection === 'inverted'\n        : I18nManager.isRTL;\n    }\n  }\n\n  private computeHorizontalGestureValue({\n    translationX,\n  }: {\n    translationX: number;\n  }) {\n    const {\n      transitionProps: { navigation, layout },\n    } = this.props;\n\n    const { index } = navigation.state;\n\n    // TODO: remove this __getValue!\n    // @ts-ignore\n    const distance: number = layout.width.__getValue();\n\n    const x = this.isMotionInverted() ? -1 * translationX : translationX;\n\n    const value = index - x / distance;\n    return clamp(index - 1, value, index);\n  }\n\n  private computeVerticalGestureValue({\n    translationY,\n  }: {\n    translationY: number;\n  }) {\n    const {\n      transitionProps: { navigation, layout },\n    } = this.props;\n\n    const { index } = navigation.state;\n\n    // TODO: remove this __getValue!\n    // @ts-ignore\n    const distance: number = layout.height.__getValue();\n\n    const y = this.isMotionInverted() ? -1 * translationY : translationY;\n    const value = index - y / distance;\n    return clamp(index - 1, value, index);\n  }\n\n  private handlePanGestureStateChange = ({\n    nativeEvent,\n  }: PanGestureHandlerGestureEvent) => {\n    // @ts-ignore\n    if (nativeEvent.oldState === GestureState.ACTIVE) {\n      // Gesture was cancelled! For example, some navigation state update\n      // arrived while the gesture was active that cancelled it out\n      // @ts-ignore\n      if (this.positionSwitch.__getValue() === 1) {\n        return;\n      }\n\n      if (this.isMotionVertical()) {\n        this.handleReleaseVertical(nativeEvent);\n      } else {\n        this.handleReleaseHorizontal(nativeEvent);\n      }\n    } else if (nativeEvent.state === GestureState.ACTIVE) {\n      this.props.onGestureBegin && this.props.onGestureBegin();\n\n      // Switch to using gesture position\n      this.positionSwitch.setValue(0);\n\n      // By enabling the gesture switch and ignoring the position here we\n      // end up with a quick jump to the initial value and then back to the\n      // gesture. While this isn't ideal, it's preferred over preventing new\n      // gestures during the animation (all gestures should be interruptible)\n      // and we will properly fix it (interruptible and from the correct position)\n      // when we integrate reanimated. If you prefer to prevent gestures during\n      // transitions, then fork this library, comment the positionSwitch value set above,\n      // and uncomment the following two lines.\n      // if (!this.props.transitionProps.position._animation) {\n      //   this.positionSwitch.setValue(0);\n      // }\n    }\n  };\n\n  // note: this will not animated so nicely because the position is unaware\n  // of the gesturePosition, so if we are in the middle of swiping the screen away\n  // and back is programatically fired then we will reset to the initial position\n  // and animate from there\n  private maybeCancelGesture() {\n    this.positionSwitch.setValue(1);\n  }\n\n  private prepareGesture() {\n    if (!this.isGestureEnabled()) {\n      // @ts-ignore\n      if (this.positionSwitch.__getValue() !== 1) {\n        this.positionSwitch.setValue(1);\n      }\n      this.gesturePosition = undefined;\n      return;\n    }\n\n    // We can't run the gesture if width or height layout is unavailable\n    if (\n      // @ts-ignore\n      this.props.transitionProps.layout.width.__getValue() === 0 ||\n      // @ts-ignore\n      this.props.transitionProps.layout.height.__getValue() === 0\n    ) {\n      return;\n    }\n\n    if (this.isMotionVertical()) {\n      this.prepareGestureVertical();\n    } else {\n      this.prepareGestureHorizontal();\n    }\n  }\n\n  private prepareGestureHorizontal() {\n    const { index } = this.props.transitionProps.navigation.state;\n\n    if (this.isMotionInverted()) {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.divide(this.gestureX, this.props.transitionProps.layout.width)\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    } else {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.multiply(\n          -1,\n          Animated.divide(\n            this.gestureX,\n            this.props.transitionProps.layout.width\n          )\n        )\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    }\n  }\n\n  private prepareGestureVertical() {\n    const { index } = this.props.transitionProps.navigation.state;\n\n    if (this.isMotionInverted()) {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.divide(this.gestureY, this.props.transitionProps.layout.height)\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    } else {\n      this.gesturePosition = Animated.add(\n        index,\n        Animated.multiply(\n          -1,\n          Animated.divide(\n            this.gestureY,\n            this.props.transitionProps.layout.height\n          )\n        )\n      ).interpolate({\n        inputRange: [index - 1, index],\n        outputRange: [index - 1, index],\n        extrapolate: 'clamp',\n      });\n    }\n  }\n\n  private handleReleaseHorizontal(\n    nativeEvent: GestureHandlerGestureEventNativeEvent &\n      PanGestureHandlerEventExtra\n  ) {\n    const {\n      transitionProps: { navigation, position, layout },\n    } = this.props;\n    const { index } = navigation.state;\n    const immediateIndex =\n      this.immediateIndex == null ? index : this.immediateIndex;\n\n    // Calculate animate duration according to gesture speed and moved distance\n    // @ts-ignore\n    const distance = layout.width.__getValue();\n    const movementDirection = this.isMotionInverted() ? -1 : 1;\n    const movedDistance = movementDirection * nativeEvent.translationX;\n    const gestureVelocity = movementDirection * nativeEvent.velocityX;\n    const defaultVelocity = distance / ANIMATION_DURATION;\n    const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n    const resetDuration = this.isMotionInverted()\n      ? (distance - movedDistance) / velocity\n      : movedDistance / velocity;\n    const goBackDuration = this.isMotionInverted()\n      ? movedDistance / velocity\n      : (distance - movedDistance) / velocity;\n\n    // Get the current position value and reset to using the statically driven\n    // (rather than gesture driven) position.\n    const value = this.computeHorizontalGestureValue(nativeEvent);\n    position.setValue(value);\n    this.positionSwitch.setValue(1);\n\n    // If the speed of the gesture release is significant, use that as the indication\n    // of intent\n    if (gestureVelocity < -50) {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this.reset(immediateIndex, resetDuration);\n      return;\n    }\n    if (gestureVelocity > 50) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this.goBack(immediateIndex, goBackDuration);\n      return;\n    }\n\n    // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n    // and the back will happen.\n    if (value <= index - POSITION_THRESHOLD) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this.goBack(immediateIndex, goBackDuration);\n    } else {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this.reset(immediateIndex, resetDuration);\n    }\n  }\n\n  private handleReleaseVertical(\n    nativeEvent: GestureHandlerGestureEventNativeEvent &\n      PanGestureHandlerEventExtra\n  ) {\n    const {\n      transitionProps: { navigation, position, layout },\n    } = this.props;\n    const { index } = navigation.state;\n    const immediateIndex =\n      this.immediateIndex == null ? index : this.immediateIndex;\n\n    // Calculate animate duration according to gesture speed and moved distance\n    // @ts-ignore\n    const distance = layout.height.__getValue();\n    const isMotionInverted = this.isMotionInverted();\n    const movementDirection = isMotionInverted ? -1 : 1;\n    const movedDistance = movementDirection * nativeEvent.translationY;\n    const gestureVelocity = movementDirection * nativeEvent.velocityY;\n    const defaultVelocity = distance / ANIMATION_DURATION;\n    const velocity = Math.max(Math.abs(gestureVelocity), defaultVelocity);\n    const resetDuration = isMotionInverted\n      ? (distance - movedDistance) / velocity\n      : movedDistance / velocity;\n    const goBackDuration = isMotionInverted\n      ? movedDistance / velocity\n      : (distance - movedDistance) / velocity;\n\n    const value = this.computeVerticalGestureValue(nativeEvent);\n    position.setValue(value);\n    this.positionSwitch.setValue(1);\n\n    // If the speed of the gesture release is significant, use that as the indication\n    // of intent\n    if (gestureVelocity < -50) {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this.reset(immediateIndex, resetDuration);\n      return;\n    }\n    if (gestureVelocity > 50) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this.goBack(immediateIndex, goBackDuration);\n      return;\n    }\n\n    // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n    // and the back will happen.\n    if (value <= index - POSITION_THRESHOLD) {\n      this.props.onGestureEnd && this.props.onGestureEnd();\n      this.goBack(immediateIndex, goBackDuration);\n    } else {\n      this.props.onGestureCanceled && this.props.onGestureCanceled();\n      this.reset(immediateIndex, resetDuration);\n    }\n  }\n\n  private getHeaderMode() {\n    if (this.props.headerMode) {\n      return this.props.headerMode;\n    }\n    if (Platform.OS === 'android' || this.props.mode === 'modal') {\n      return 'screen';\n    }\n    // On web, the float header mode will enable body scrolling and stick the header\n    // to the top of the URL bar when it shrinks and expands.\n    return 'float';\n  }\n\n  private getHeaderBackgroundTransitionPreset() {\n    const { headerBackgroundTransitionPreset } = this.props;\n    if (headerBackgroundTransitionPreset) {\n      if (\n        HEADER_BACKGROUND_TRANSITION_PRESET.includes(\n          headerBackgroundTransitionPreset\n        )\n      ) {\n        if (headerBackgroundTransitionPreset === 'fade') {\n          return HeaderStyleInterpolator.forBackgroundWithFade;\n        } else if (headerBackgroundTransitionPreset === 'translate') {\n          return HeaderStyleInterpolator.forBackgroundWithTranslation;\n        } else if (headerBackgroundTransitionPreset === 'toggle') {\n          return HeaderStyleInterpolator.forBackgroundWithInactiveHidden;\n        }\n      } else if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerBackgroundTransitionPreset - expected one of ${HEADER_BACKGROUND_TRANSITION_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerBackgroundTransitionPreset)}`\n        );\n      }\n    }\n\n    return null;\n  }\n\n  private getHeaderLayoutPreset() {\n    const { headerLayoutPreset } = this.props;\n    if (headerLayoutPreset) {\n      if (__DEV__) {\n        if (\n          this.getHeaderTransitionPreset() === 'uikit' &&\n          headerLayoutPreset === 'left' &&\n          Platform.OS === 'ios'\n        ) {\n          console.warn(\n            `headerTransitionPreset with the value 'uikit' is incompatible with headerLayoutPreset 'left'`\n          );\n        }\n      }\n      if (HEADER_LAYOUT_PRESET.includes(headerLayoutPreset)) {\n        return headerLayoutPreset;\n      }\n\n      if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerLayoutPreset - expected one of ${HEADER_LAYOUT_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerLayoutPreset)}`\n        );\n      }\n    }\n\n    if (Platform.OS !== 'ios') {\n      return 'left';\n    } else {\n      return 'center';\n    }\n  }\n\n  private getHeaderTransitionPreset() {\n    // On Android or with header mode screen, we always just use in-place,\n    // we ignore the option entirely (at least until we have other presets)\n    if (Platform.OS !== 'ios' || this.getHeaderMode() === 'screen') {\n      return 'fade-in-place';\n    }\n\n    const { headerTransitionPreset } = this.props;\n    if (headerTransitionPreset) {\n      if (HEADER_TRANSITION_PRESET.includes(headerTransitionPreset)) {\n        return headerTransitionPreset;\n      }\n\n      if (__DEV__) {\n        console.error(\n          `Invalid configuration applied for headerTransitionPreset - expected one of ${HEADER_TRANSITION_PRESET.join(\n            ', '\n          )} but received ${JSON.stringify(headerTransitionPreset)}`\n        );\n      }\n    }\n\n    return 'fade-in-place';\n  }\n\n  private getHeaderBackTitleVisible() {\n    const { headerBackTitleVisible } = this.props;\n    const layoutPreset = this.getHeaderLayoutPreset();\n\n    // Even when we align to center on Android, people should need to opt-in to\n    // showing the back title\n    const enabledByDefault = !(\n      layoutPreset === 'left' || Platform.OS !== 'ios'\n    );\n\n    return typeof headerBackTitleVisible === 'boolean'\n      ? headerBackTitleVisible\n      : enabledByDefault;\n  }\n\n  private renderInnerScene(scene: Scene) {\n    const { navigation, getComponent } = scene.descriptor;\n    const SceneComponent = getComponent();\n\n    const { screenProps } = this.props;\n    const headerMode = this.getHeaderMode();\n    if (headerMode === 'screen') {\n      return (\n        <View style={styles.container}>\n          <View style={styles.scenes}>\n            <SceneView\n              screenProps={screenProps}\n              navigation={navigation}\n              component={SceneComponent}\n            />\n          </View>\n          {this.renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n    return (\n      <SceneView\n        screenProps={screenProps}\n        navigation={navigation}\n        component={SceneComponent}\n      />\n    );\n  }\n\n  private prepareTransitionConfig() {\n    this.transitionConfig = TransitionConfigs.getTransitionConfig(\n      this.props.transitionConfig,\n      {\n        ...this.props.transitionProps,\n        position: this.position,\n      },\n      this.props.lastTransitionProps,\n      this.isModal()\n    );\n  }\n\n  private preparePosition() {\n    if (this.gesturePosition) {\n      // FIXME: this doesn't seem right, there is setValue called in some places\n      // @ts-ignore\n      this.position = Animated.add(\n        Animated.multiply(\n          this.props.transitionProps.position,\n          this.positionSwitch\n        ),\n        Animated.multiply(this.gesturePosition, this.gestureSwitch)\n      );\n    } else {\n      this.position = this.props.transitionProps.position;\n    }\n  }\n\n  private renderCard = (scene: Scene) => {\n    const {\n      transitionProps,\n      cardShadowEnabled,\n      cardOverlayEnabled,\n      transparentCard,\n      cardStyle,\n    } = this.props;\n\n    const { screenInterpolator } = this.transitionConfig as TransitionConfig;\n    const style =\n      screenInterpolator &&\n      screenInterpolator({\n        ...transitionProps,\n        shadowEnabled: cardShadowEnabled,\n        cardOverlayEnabled,\n        position: this.position,\n        scene,\n      });\n\n    // When using a floating header, we need to add some top\n    // padding on the scene.\n    const { options } = scene.descriptor;\n    const hasHeader = options.header !== null && options.headerShown !== false;\n    const headerMode = this.getHeaderMode();\n\n    let floatingContainerStyle: ViewStyle = StyleSheet.absoluteFill as ViewStyle;\n\n    if (hasHeader && headerMode === 'float' && !options.headerTransparent) {\n      floatingContainerStyle = {\n        ...Platform.select({\n          web: {} as ViewStyle,\n          default: StyleSheet.absoluteFillObject,\n        }),\n        paddingTop: this.state.floatingHeaderHeight,\n      };\n    }\n\n    return (\n      <Card\n        {...transitionProps}\n        key={`card_${scene.key}`}\n        position={this.position}\n        realPosition={transitionProps.position}\n        animatedStyle={style}\n        transparent={transparentCard}\n        style={[floatingContainerStyle, cardStyle]}\n        scene={scene}\n      >\n        {this.renderInnerScene(scene)}\n      </Card>\n    );\n  };\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    // Header is physically rendered after scenes so that Header won't be\n    // covered by the shadows of the scenes.\n    // That said, we'd have use `flexDirection: 'column-reverse'` to move\n    // Header above the scenes.\n    flexDirection: 'column-reverse',\n    overflow: 'hidden',\n  },\n  scenes: {\n    flex: 1,\n  },\n  floatingHeader: {\n    // @ts-ignore\n    position: Platform.select({ default: 'absolute', web: 'fixed' }),\n    left: 0,\n    top: 0,\n    right: 0,\n  },\n});\n\nexport default withOrientation(StackViewLayout);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}